package main

import (
	"fmt"
	"os"
	"os/user"
	"regexp"
	"strings"
)

const ShellScriptString = `
#!/usr/bin/env bash
# Automatically generated by olins
# Author: @pabloskubert

# Set some bash options
set -e -o pipefail
set -f -o noglob

# Set some variables
NEED_ROOT="{need_root}"
NEED_ARGS_QTD="{qtd_args}"

# List of input args
GetVars=({vars})

# Usage message
USAGE="\nUsage: $0 ${GetVars[@]}\n"

function trap_ctrlc() {
  echo -e "\n\n Exiting script"
  exit 1
}

# Trap Ctrl+C
trap trap_ctrlc SIGINT
trap trap_ctrlc SIGTERM

# Check if the script is running as root (if needed)
if [ "$NEED_ROOT" -eq 1 ] && [ "$EUID" -ne 0 ]; then
  echo -e "\n This script must be run as root"
  exit 1
fi

# Check the number of arguments 
if [ "$#" -lt "$NEED_ARGS_QTD" ]; then
  echo -e "$USAGE"
  echo -e "Command: {command_str}\n"
  exit 1
fi

# Display test message
if [ "$1" = "test" ]; then
  echo -e "\n Working!"
  exit
fi

# For each var, declare with the input arg 
for inpt_arg in "${GetVars[@]}"; do
  declare "$inpt_arg"="$1"
  shift
done

command_string="{command}"

echo -e "\n Running command: $command_string \n"
eval "$command_string"

# Wait any process
wait
`

type Saver struct {
	Command  string
	Name     string
	IsRoot   int
	savepath string
	vars     []string
	script   string
}

func (s *Saver) Save() {
	s.setup()
	s.createScript()
	fmt.Println("Ok saved in: " + s.savepath)
}

func (s *Saver) setup() {
	var err error
	var currentUser *user.User

	currentUser, err = user.Current()
	if err != nil {
		panic(err)
	}

	s.savepath = currentUser.HomeDir + "/.olins"

	// Create the savepath if not exists
	if _, err = os.Stat(s.savepath); os.IsNotExist(err) {
		err = os.Mkdir(s.savepath, 0755)
		if err != nil {
			panic(err)
		}
	}

	s.savepath += "/" + s.Name
}

func (s *Saver) createScript() {
	var FindVarsRegex = regexp.MustCompile(`{\w+}`)
	var FoundVars = FindVarsRegex.FindAllString(s.Command, -1)
	var Vars = make([]string, len(FoundVars))

	if len(FoundVars) == 0 {
		fmt.Println("Warn: no variables found")
	}

	// Add $ before { and } to make the variable bash compatible in Command string
	var commandCat = strings.ReplaceAll(s.Command, "{", "${")

	// Transform found vars to bash compatible ("var_one" "var_two" "var_three")
	for i, v := range FoundVars {
		FoundVars[i] = v[1 : len(v)-1]
		Vars[i] = fmt.Sprintf("\"%s\"", FoundVars[i])
	}

	// Add the variables to the script
	var Script = ShellScriptString
	Script = strings.ReplaceAll(Script, "{command}", commandCat)
	Script = strings.ReplaceAll(Script, "{command_str}", s.Command)
	Script = strings.ReplaceAll(Script, "{need_root}", fmt.Sprintf("%d", s.IsRoot))
	Script = strings.ReplaceAll(Script, "{qtd_args}", fmt.Sprintf("%d", len(FoundVars)))
	Script = strings.ReplaceAll(Script, "{vars}", strings.Join(Vars, " "))

	var file, err = os.Create(s.savepath)
	if err != nil {
		fmt.Println("Error: cannot create the file")
		panic(err)
	}

	// Write the script to ~/.olins
	_, err = file.WriteString(Script)
	if err != nil {
		fmt.Println("Error: cannot write the file")
		panic(err)
	}

	// Set the file as executable
	err = file.Chmod(0755)
	if err != nil {
		fmt.Println("Error: cannot set the file as executable")
		panic(err)
	}
}
